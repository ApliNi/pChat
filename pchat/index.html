<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="keywords" content="AI, Chat, Puter.js, Free, Qwen, DeepSeek, Claude, GPT">
    <title>[Chat] Loading...</title><meta name="description" content="åŸºäº Puter.js çš„æœ¬åœ°å…è´¹ AI èŠå¤©">
	<meta name="theme-color" content="#202124">
	<link rel="manifest" href="./manifest.json?v=1">
    <style>

		@font-face {
			font-family: 'HarmonyOS';
			font-display: swap;
			src: url('./HarmonyOS_Sans_SC_Medium.subset.woff2') format('woff2');
		}

		@font-face {
			font-family: 'JetBrainsMono';
			font-display: swap;
			src: url('./JetBrainsMono-Regular.woff2') format('woff2');
		}

		@font-face {
			font-family: 'Ubuntu';
			font-display: swap;
			src: url('./Ubuntu-Regular.subset.woff2?v=2') format('woff2'),
				local('JetBrainsMono');
			word-spacing: -5px; /*ç­‰å®½ç©ºæ ¼é—´è·å¤ªå¤§*/
		}

        :root {
            --bg-color: #0d0d0d;
            --sidebar-bg: #0a0a0a;
            --text-color: #e0e0e0;
            --border-color: #333;
            --user-msg-color: #00ff00;
            --ai-msg-color: #ffffff;
            --sys-msg-color: #00ccff;
            --meta-color: #555;
            --danger-color: #ff3333;
            --active-item-bg: #161616;
            --font-stack: 'JetBrainsMono', 'HarmonyOS', 'Segoe UI Emoji', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
        }

        * { box-sizing: border-box; margin: 0; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-stack);
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 13px;
            overflow: hidden;
        }

        /* --- Global Header --- */
        header {
            border-bottom: 1px solid var(--border-color);
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #000;
            flex-shrink: 0;
            height: 45px;
        }

        h1 { font-size: 14px; font-weight: normal; letter-spacing: 1px; color: #fff; font-family: 'Ubuntu', 'HarmonyOS'; }

        .header-controls { display: flex; align-items: center; gap: 15px; }

        .model-select-wrapper { position: relative; }
        .model-select-wrapper::after {
            content: 'â–¼'; font-size: 10px; position: absolute; right: 8px; top: 50%;
            transform: translateY(-50%); pointer-events: none; color: var(--meta-color);
        }

        #model-select {
            appearance: none; -webkit-appearance: none;
            background: #000; color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 4px 25px 4px 10px;
            font-family: var(--font-stack); font-size: 12px;
            cursor: pointer; outline: none; border-radius: 0;
            text-transform: uppercase;
			width: 300px;
			transition: all 0.3s;
        }
        #model-select:hover { border-color: #fff; }

        .status-dot {
            height: 8px; width: 8px; background: #333; transition: all 0.3s;
        }
        .status-dot.active {
            background: var(--user-msg-color); box-shadow: 0 0 8px var(--user-msg-color);
        }

        /* --- Chat Container --- */
        #chat-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* --- Sidebar --- */
        #sidebar {
            width: 240px;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            font-size: 12px;
        }

        .sidebar-header {
            padding: 10px;
            border-bottom: 1px solid #1a1a1a;
            text-align: center;
        }

        #new-chat-btn {
            background: transparent;
            color: #666;
            border: 1px dashed #333;
            width: 100%;
            padding: 8px;
            font-family: var(--font-stack);
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }
        #new-chat-btn:hover {
            color: #fff;
            border-color: #666;
            background: rgba(255,255,255,0.05);
        }

        #history-list {
            flex: 1;
            overflow-y: auto;
            padding: 5px 0;
        }

        .history-item {
            padding: 10px 15px;
            cursor: pointer;
            border-left: 2px solid transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
            color: #888;
        }

        .history-item:hover { background: #111; color: #ccc; }
        .history-item.active {
            background: var(--active-item-bg);
            border-left-color: var(--user-msg-color);
            color: #fff;
        }

        .history-info { flex: 1; overflow: hidden; }
        .history-title {
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            margin-bottom: 3px; border: 1px solid transparent;
            padding: 2px;
        }
        /* Editable Title Style */
        .history-title[contenteditable="plaintext-only"] {
            background: #000;
            color: #fff;
            border: 1px dashed #555;
            cursor: text;
			outline: none;
        }

        .history-date { font-size: 10px; color: #444; font-family: sans-serif; }

        .history-del-btn {
            background: transparent; border: none; color: #444;
            cursor: pointer; font-size: 14px; padding: 5px; margin-left: 5px;
            opacity: 0; transition: all 0.2s;
        }
        .history-item.active .history-del-btn, .history-item:hover .history-del-btn { opacity: 1; }
        .history-del-btn:hover { color: var(--danger-color); }

        /* --- Right Panel --- */
        #right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            background: var(--bg-color);
        }

        #message-area {
            flex: 1;
            padding: 20px 20px 0 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .message {
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
            padding: 10px 15px;
            border-left: 2px solid transparent;
            animation: fadeIn 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .message.user { border-left-color: var(--user-msg-color); background: rgba(0, 255, 0, 0.02); }
        .message.assistant { border-left-color: var(--ai-msg-color); background: rgba(255, 255, 255, 0.02); }
        .message.system { border-left-color: var(--sys-msg-color); background: rgba(0, 204, 255, 0.02); }

        .role-label {
            font-size: 10px; opacity: 0.5; margin-bottom: 6px;
            display: flex; justify-content: space-between;
            text-transform: uppercase;
        }

        .content {
            white-space: pre-wrap; word-break: break-all; margin-bottom: 6px;
            outline: none; transition: background 0.2s; background: rgba(255,255,255,0);
        }
        .content:focus { background: rgba(255,255,255,0.03); }

        .msg-footer {
            display: flex; justify-content: space-between; align-items: center;
            border-top: 1px dashed #222; padding-top: 4px; margin-top: 2px;
        }

        .left-actions { display: flex; gap: 8px; }
        .action-btn {
            background: transparent; border: none;
            font-family: var(--font-stack); font-size: 9px;
            cursor: pointer; padding: 0; opacity: 0.5;
            transition: all 0.2s; text-transform: uppercase;
        }
        .action-btn:hover { opacity: 1; }
        .btn-del, .btn-regen { color: var(--meta-color); }
        .btn-del:hover, .btn-regen:hover { color: #fff; }
        .btn-del.confirm-state { color: var(--danger-color); font-weight: bold; opacity: 1; }
        
        .meta-stats { font-size: 9px; color: #444; text-align: right; min-height: 14px; }

        /* --- Input Area --- */
        #input-container {
            flex-shrink: 0;
            padding: 20px 20px 40px 20px;
            background: var(--bg-color);
            border-top: 1px solid transparent;
        }

        .input-group {
            max-width: 800px; margin: 0 auto;
            display: flex; border: 1px solid var(--border-color);
        }

        textarea {
            flex: 1; background: #000; color: var(--text-color);
            border: none; padding: 12px;
            font-family: var(--font-stack); font-size: 14px;
            resize: none; height: 42px; min-height: 42px; max-height: 200px;
			outline: none;
        }

        #send-btn {
            background: #111; color: var(--text-color);
            border: none; border-left: 1px solid var(--border-color);
            padding: 0 25px; font-family: var(--font-stack);
            cursor: pointer; font-weight: bold; text-transform: uppercase;
            transition: all 0.2s;
        }
        #send-btn:hover { background: rgba(255, 255, 255, 0.05); color: #fff; }
        #send-btn:disabled { background: #111; color: #444; cursor: not-allowed; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: 0; } }
        .cursor::after { content: 'â–ˆ'; animation: blink 1s step-end infinite; margin-left: 2px; color: var(--ai-msg-color); }
        @keyframes blink { 50% { opacity: 0; } }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

		/* --- Compact Terminal Markdown Style --- */
        .markdown-body {
			display: table;
            font-family: var(--font-stack);
            font-size: 13px; /* ä¿æŒä¸ç³»ç»Ÿä¸€è‡´ */
            line-height: 1.5; /* ç¨å¾®è°ƒå°è¡Œé«˜ */
            color: var(--text-color);
            background: transparent;
            word-wrap: break-word;
        }

        /* æ ¸å¿ƒï¼šç§»é™¤é¦–å°¾å…ƒç´ çš„é—´è·ï¼Œé˜²æ­¢æ°”æ³¡è¢«æ’‘å¤§ */
        .markdown-body > *:first-child { margin-top: 0 !important; }
        .markdown-body > *:last-child { margin-bottom: 0 !important; }

        /* æ ‡é¢˜ï¼šå¤§å¹…å‡å°é—´è·ï¼Œä½¿ç”¨æ›´ç»†è…»çš„ä¸‹åˆ’çº¿ */
        .markdown-body h1, .markdown-body h2, .markdown-body h3,
        .markdown-body h4, .markdown-body h5, .markdown-body h6 {
            margin-top: 1.2em; /* ç¼©å°ä¸Šæ–¹é—´è· */
            margin-bottom: 0.6em; /* ç¼©å°ä¸‹æ–¹é—´è· */
            font-weight: bold;
            color: #fff;
            border-bottom: 1px solid #333; /* å®çº¿æ¯”è™šçº¿æ›´å¹²å‡€ */
            padding-bottom: 4px;
            line-height: 1.3;
        }
        
        /* ç¨å¾®åŒºåˆ†ä¸€ä¸‹æ ‡é¢˜ç­‰çº§ */
        .markdown-body h1 { font-size: 1.3em; border-bottom-color: #555; }
        .markdown-body h2 { font-size: 1.15em; }
        .markdown-body h3 { font-size: 1.1em; border: none; } /* h3ä»¥ä¸‹ä¸è¦ä¸‹åˆ’çº¿ï¼Œå¤ªä¹± */
        .markdown-body h4 { font-size: 1em; border: none; }

        /* æ®µè½ï¼šå‡å°é—´è· */
        .markdown-body p {
            margin: 0.8em 0;
        }

        /* åˆ—è¡¨ï¼šç´§å‡‘å¸ƒå±€ */
        .markdown-body ul, .markdown-body ol {
			display: table;
            padding-left: 20px; /* å‡å°ç¼©è¿› */
			width: 100%;
        }
        
        /* åˆ—è¡¨é¡¹ä¹‹é—´ä¸è¦æœ‰å¤ªå¤§ç©ºéš™ï¼Œä½†ä¿ç•™ä¸€ç‚¹ç‚¹å‘¼å¸æ„Ÿ */
        .markdown-body li {
			display: table;
            margin: 0.4rem 0;
			width: 100%;
        }
        .markdown-body li > p {
            margin: 4px 0; /* åˆ—è¡¨å†…çš„æ®µè½ä¹Ÿä¸è¦å¤ªå¤§é—´è· */
        }
        
        /* åµŒå¥—åˆ—è¡¨æ›´ç´§å‡‘ */
        .markdown-body ul ul, .markdown-body ul ol,
        .markdown-body ol ul, .markdown-body ol ol {
			display: table;
            margin-top: 4px;
            margin-bottom: 0;
        }

        /* åˆ†å‰²çº¿ï¼šæš—æ·¡ä¸€ç‚¹ï¼Œä¸è¦å¤ªæŠ¢çœ¼ */
        .markdown-body hr {
            height: 0;
            margin: 15px 0;
            border: none;
            border-top: 1px dashed #333;
        }

        /* å¼•ç”¨å—ï¼šæ›´èåˆèƒŒæ™¯ */
        .markdown-body blockquote {
			display: table;
            margin: 10px 0;
            padding: 4px 12px;
			width: 100%;
            color: #888;
            border-left: 3px solid #444; /* è¾¹æ¡†è°ƒç»†è°ƒæš— */
            background: rgba(255,255,255,0.03); /* èƒŒæ™¯ææ·¡ */
        }

        /* é“¾æ¥ */
        .markdown-body a {
            color: var(--sys-msg-color);
            text-decoration: none;
            border-bottom: 1px dotted rgba(0, 204, 255, 0.5);
        }
        .markdown-body a:hover {
            border-bottom-style: solid;
        }

        /* è¡¨æ ¼ */
        .markdown-body table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 10px;
            font-size: 12px;
        }
        .markdown-body th, .markdown-body td {
            border: 1px solid #333;
            padding: 4px 8px; /* å‡å°å•å…ƒæ ¼å†…è¾¹è· */
        }
        .markdown-body th {
            background: #111;
            color: #ddd;
            font-weight: bold;
        }

        /* --- ä»£ç æ ·å¼ä¼˜åŒ– --- */

        /* è¡Œå†…ä»£ç ï¼šæ›´åƒé«˜äº®ç¬”ï¼Œè€Œä¸æ˜¯æ–¹å— */
        .markdown-body :not(pre) > code {
            font-family: var(--font-stack);
            background: rgba(255, 204, 0, 0.1); /* ææ·¡çš„ç¥ç€è‰²èƒŒæ™¯ */
            color: #ffcc00; /* ç¥ç€è‰²æ–‡å­— */
            padding: 0 4px;
            border-radius: 2px;
            font-size: 0.95em;
        }

        /* ä»£ç å—ï¼šæ·±è‰²èƒŒæ™¯ï¼Œæ— åœ†è§’ */
        .markdown-body pre {
            background: #0d0d0d; /* æ¯”æ°”æ³¡èƒŒæ™¯æ›´æ·±ä¸€ç‚¹ */
            border: 1px solid #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin-bottom: 10px;
        }
        
        .markdown-body pre code {
            background: transparent;
            padding: 0;
            color: inherit;
            white-space: pre;
            font-size: 12px; /* ä»£ç ç¨å¾®å°ä¸€ç‚¹ */
        }

		/* æœ€åä¸€ä¸ªå…ƒç´ ä¸æ·»åŠ  margin-bottom */
		.markdown-body ul > li:last-child,
		.markdown-body li > *:last-child
		{ margin-bottom: 0 !important; }

        /* --- Custom Syntax Highlighting (Vivid Dark) --- */
        /* è¿™é‡Œçš„é¢œè‰²ç»è¿‡è°ƒæ•´ï¼Œä»¥é€‚åº”é»‘è‰²èƒŒæ™¯ */
        
        /* å…³é”®å­—: ç´«è‰²/ç²‰è‰² */
        .hljs-keyword, .hljs-operator, .hljs-tag { color: #c678dd; }
        
        /* å‡½æ•°å/ç±»å: è“è‰² */
        .hljs-function, .hljs-title, .hljs-section { color: #61afef; }
        
        /* å­—ç¬¦ä¸²: ç»¿è‰² (ç¬¦åˆç»ˆç«¯ç›´è§‰) */
        .hljs-string, .hljs-attr { color: #98c379; }
        
        /* å˜é‡/å±æ€§: çº¢è‰²/æ©˜è‰² */
        .hljs-variable, .hljs-template-variable, .hljs-attribute { color: #e06c75; }
        
        /* æ³¨é‡Š: æš—ç°è‰²ï¼Œæ–œä½“ */
        .hljs-comment, .hljs-quote { color: #5c6370; font-style: italic; }
        
        /* æ•°å­—/å¸ƒå°”å€¼/å¸¸é‡: æ©˜è‰² */
        .hljs-number, .hljs-literal, .hljs-symbol { color: #d19a66; }
        
        /* æ ‡ç‚¹ç¬¦å· */
        .hljs-punctuation { color: #abb2bf; }

        /* --- CSS Only Mobile Menu --- */

		/* é»˜è®¤éšè—èœå•æŒ‰é’® */
		.menu-btn {
			display: none;
			font-size: 20px;
			cursor: pointer;
			margin-right: 15px;
			color: #fff;
			user-select: none;
		}

		@media (max-width: 768px) {
			.menu-btn { display: block; }

			#sidebar {
				position: absolute;
				left: -300px;
				z-index: 100;
				width: 240px;
				height: 100%;
				box-shadow: 10px 0 20px rgba(0,0,0,0.8);
				transition: left 0.3s;
			}

			#sidebar-toggle:checked ~ #chat-container #sidebar {
				left: 0;
			}

			header h1 { display: none; }

			#model-select { width: 100%; }
		}

    </style>
</head>
<body>

<input type="checkbox" id="sidebar-toggle" style="display: none;">

<header>
	<label for="sidebar-toggle" class="menu-btn">â˜°</label>
    <h1>./pChat/ (ï½¡ãƒ»Ì€á´—-)âœ§</h1>
    <div class="header-controls">
        <div class="model-select-wrapper">
            <select id="model-select"></select>
        </div>
        <div id="status-dot" class="status-dot"></div>
    </div>
</header>

<div id="chat-container">
    <aside id="sidebar">
        <div class="sidebar-header">
            <button id="new-chat-btn">[ + NEW SESSION ]</button>
        </div>
        <div id="history-list"></div>
    </aside>

    <main id="right-panel">
        <div id="message-area"></div>
        <div id="input-container">
            <div class="input-group">
                <textarea id="user-input" placeholder=" > Start typing a prompt" autofocus></textarea>
                <button id="send-btn">SEND</button>
            </div>
        </div>
    </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://js.puter.com/v2/"></script>
<script>

	// CONFIG
	const priorityModels = ['qwen3-max', 'deepseek-v3.2-exp', 'claude-sonnet-4-5', 'gpt-4.1'];

	marked.setOptions({
        highlight: function(code, lang) {
            const language = highlight.getLanguage(lang) ? lang : 'plaintext';
            return highlight.highlight(code, { language }).value;
        },
        langPrefix: 'hljs language-',
        breaks: true,
        gfm: true,
    });

    // --- IndexedDB Manager ---
    const IDBManager = {
        dbName: 'PuterChatDB',
        version: 1,
        db: null,

        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, this.version);

                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    // Store for session metadata (id, title, timestamp)
                    if (!db.objectStoreNames.contains('sessions')) {
                        db.createObjectStore('sessions', { keyPath: 'id' });
                    }
                    // Store for chat messages (sessionId as key, content as array)
                    if (!db.objectStoreNames.contains('chats')) {
                        db.createObjectStore('chats', { keyPath: 'id' });
                    }
                };

                request.onsuccess = (e) => {
                    this.db = e.target.result;
                    resolve(this.db);
                };

                request.onerror = (e) => {
                    console.error("IndexedDB Error:", e);
                    reject(e);
                };
            });
        },

        async getAllSessions() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction('sessions', 'readonly');
                const store = tx.objectStore('sessions');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        },

        async saveSessionMeta(session) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction('sessions', 'readwrite');
                const store = tx.objectStore('sessions');
                const request = store.put(session);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        },

        async deleteSession(sessionId) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(['sessions', 'chats'], 'readwrite');
                tx.objectStore('sessions').delete(sessionId);
                tx.objectStore('chats').delete(sessionId);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        },

        async getSessionMessages(sessionId) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction('chats', 'readonly');
                const store = tx.objectStore('chats');
                const request = store.get(sessionId);
                request.onsuccess = () => {
                    const res = request.result;
                    resolve(res ? res.messages : []);
                };
                request.onerror = () => reject(request.error);
            });
        },

        async saveSessionMessages(sessionId, messages) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction('chats', 'readwrite');
                const store = tx.objectStore('chats');
                const request = store.put({ id: sessionId, messages: messages });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
    };

    // --- DOM Elements ---
    const messageArea = document.getElementById('message-area');
    const userInput = document.getElementById('user-input');
    const sendBtn = document.getElementById('send-btn');
    const statusDot = document.getElementById('status-dot');
    const modelSelect = document.getElementById('model-select');
    const historyList = document.getElementById('history-list');
    const newChatBtn = document.getElementById('new-chat-btn');

    // --- State Management ---
    let chatHistory = [];
    let isProcessing = false;
    let currentSessionId = null;
    let sessions = [];
	let isAutoScroll = true;

    // --- Utilities ---
    const generateId = () => 'msg_' + Date.now() + '_' + Math.floor(Math.random() * 10000);
    const generateSessionId = () => 'sess_' + Date.now();
    
    const formatDate = (ts) => {
        const d = new Date(ts);
        const year = d.getFullYear();
        const month = (d.getMonth() + 1).toString().padStart(2, '0');
        const day = d.getDate().toString().padStart(2, '0');
        const hour = d.getHours().toString().padStart(2, '0');
        const minute = d.getMinutes().toString().padStart(2, '0');
        return `${year}/${month}/${day} ${hour}:${minute}`;
    };

    // --- Storage Logic (Wrapper around IDBManager) ---
    async function loadSessionsIndex() {
        try {
            sessions = await IDBManager.getAllSessions();
            renderSidebar();
        } catch (e) {
            console.error("Failed to load sessions", e);
        }
    }

    async function saveSessionMetaLocal(session) {
        // Find if exists and update, or push
        const idx = sessions.findIndex(s => s.id === session.id);
        if (idx !== -1) {
            sessions[idx] = session;
        } else {
            sessions.push(session);
        }
        await IDBManager.saveSessionMeta(session);
        renderSidebar();
    }

    async function saveCurrentSession() {
        if (!currentSessionId) return;
        await IDBManager.saveSessionMessages(currentSessionId, chatHistory);
    }

    async function deleteSession(e, sessionId) {
        e.stopPropagation();
        if (!confirm('DELETE SESSION PERMANENTLY?')) return;

        sessions = sessions.filter(s => s.id !== sessionId);
        await IDBManager.deleteSession(sessionId);

        if (sessionId === currentSessionId) {
            await createNewSession();
        } else {
            renderSidebar();
        }
    }

    async function renameSession(e, sessionId, newTitle) {
        const session = sessions.find(s => s.id === sessionId);
        if (session) {
            session.title = newTitle;
            await IDBManager.saveSessionMeta(session);
        }
    }

    // --- UI Logic: Sidebar ---
    function renderSidebar() {
        historyList.innerHTML = '';
        const sortedSessions = [...sessions].sort((a, b) => b.timestamp - a.timestamp);

        sortedSessions.forEach(session => {
            const div = document.createElement('div');
            div.className = `history-item ${session.id === currentSessionId ? 'active' : ''}`;
            
            // Note: We move the onclick to the div, but we need to prevent bubble for edit/delete
            div.onclick = (e) => {
                // If we are currently editing a title, don't switch
                if (e.target.isContentEditable) return;
                switchSession(session.id);
				document.getElementById('sidebar-toggle').checked = false;
            };
            
            div.innerHTML = `
                <div class="history-info">
                    <div class="history-title" title="Double click to rename">${session.title}</div>
                    <div class="history-date">${formatDate(session.timestamp)}</div>
                </div>
                <button class="history-del-btn">Ã—</button>
            `;

            // Setup Delete Button
            const delBtn = div.querySelector('.history-del-btn');
            delBtn.onclick = (e) => deleteSession(e, session.id);

            // Setup Rename (Double Click)
            const titleDiv = div.querySelector('.history-title');
            titleDiv.ondblclick = (e) => {
                e.stopPropagation(); // Prevent switching session
                makeTitleEditable(titleDiv, session.id);
            };

            historyList.appendChild(div);
        });
    }

    function makeTitleEditable(element, sessionId) {
        element.contentEditable = 'plaintext-only';
        element.focus();
        
        // Select all text
        const range = document.createRange();
        range.selectNodeContents(element);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);

        const save = async () => {
            element.contentEditable = false;
            const newTitle = element.innerText.trim() || "Untitled Session";
            await renameSession(null, sessionId, newTitle);
            // Re-render to sort or format correctly if needed, or just let it be
            // renderSidebar(); // Optional: might disrupt if editing multiple
        };

        const onKeyDown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                element.blur();
            }
        };

        element.addEventListener('blur', save, { once: true });
        element.addEventListener('keydown', onKeyDown);
    }

    async function switchSession(sessionId) {
        if (isProcessing) return;
        if (currentSessionId === sessionId) return;

        currentSessionId = sessionId;

		const session = sessions.find(s => s.id === sessionId);
		if (session) {
			document.title = `[Chat] ${session.title}`;
		}

        try {
            chatHistory = await IDBManager.getSessionMessages(sessionId);
        } catch (e) {
            chatHistory = [];
        }
        
        messageArea.innerHTML = '';
        chatHistory.forEach(msg => {
            // appendMessageToDOM åªæ˜¯åˆ›å»ºç»“æ„
            const els = appendMessageToDOM(msg.role, '', msg.id, msg.model || null, false);
            
            // è¿™é‡Œæ‰‹åŠ¨æ¸²æŸ“å†…å®¹
            if (msg.role === 'assistant') {
                els.contentDiv.innerHTML = DOMPurify.sanitize(marked.parse(msg.content));
            } else {
                // ç”¨æˆ·æ¶ˆæ¯é€šå¸¸ä¿æŒçº¯æ–‡æœ¬ï¼Œæˆ–è€…ä½ ä¹Ÿæƒ³æ”¯æŒç”¨æˆ·å‘ markdownï¼Œå°±ç”¨ä¸Šé¢ä¸€æ ·çš„é€»è¾‘
                els.contentDiv.textContent = msg.content;
            }
			els.contentDiv.classList.remove('cursor');
        });
        
        renderSidebar();
        scrollToBottom();
    }

	async function createIntroSession() {
		const introId = 'sess_welcome'; // å›ºå®š ID
		const timestamp = Date.now();

		// 1. å®šä¹‰æ¬¢è¿ä¼šè¯çš„å…ƒæ•°æ®
		const introSession = {
			id: introId,
			title: 'Instructions for use ğŸ‘‹',
			timestamp: timestamp
		};

		// 2. å®šä¹‰é¢„è®¾çš„èŠå¤©è®°å½•
		const introMessages = [
			{
				role: 'system',
				id: 'msg_sys_intro',
				content: `
[ Puter.js AI Chat Terminal ]

è¿™æ˜¯ä¸€ä¸ªåŸºäº Puter.js çš„æœ¬åœ°åŒ– AI èŠå¤©ç»ˆç«¯.

## ç‰¹æ€§
- å…è´¹: æ— éœ€æ³¨å†Œ, æ— éœ€ç™»å½•, æ— éœ€æ”¯ä»˜, é€šè¿‡ Puter.js æä¾›å®Œå…¨å…è´¹çš„æœåŠ¡.
- æœ¬åœ°å­˜å‚¨: æ‰€æœ‰èŠå¤©è®°å½•é€šè¿‡ IndexedDB å­˜å‚¨åœ¨æµè§ˆå™¨æœ¬åœ°, é™¤ AI æ¨ç†å¤–, ä¸ä¸Šä¼ åˆ°ä»»ä½•æœåŠ¡å™¨.

## åŠŸèƒ½
- æ¨¡å‹åˆ‡æ¢: åœ¨å³ä¸Šè§’ä¸‹æ‹‰èœå•ä¸­åˆ‡æ¢æ¨¡å‹, è½¯ä»¶ä¼šè®°ä½ä¸Šä¸€æ¬¡ä½¿ç”¨çš„æ¨¡å‹.
- ä¼šè¯ç®¡ç†: å·¦ä¾§ä¾§è¾¹æ é€‰æ‹©æ”¯æŒ åˆ‡æ¢/æ–°å»º/åˆ é™¤, åŒå‡»ä¼šè¯æ ‡é¢˜å¯é‡å‘½å.
- æ¶ˆæ¯ç¼–è¾‘: æ‰€æœ‰æ¶ˆæ¯å‡æ”¯æŒ ç¼–è¾‘/åˆ é™¤, AI æ¶ˆæ¯æ”¯æŒé‡æ–°ç”Ÿæˆ.

## å¼€æº
- [GitHub](https://github.com/ApliNi/Puter.js-AI-Chat-Terminal)
- [Puter.js](https://github.com/heyPuter/puter)

`,
			},
		];

		// 3. ä¿å­˜åˆ°æ•°æ®åº“å’Œå†…å­˜
		// æ³¨æ„ï¼šè¿™é‡Œæ‰‹åŠ¨æ›´æ–°å†…å­˜å’ŒDBï¼Œä¸è°ƒç”¨ createNewSession ä»¥å…é€»è¾‘å†²çª
		await saveSessionMetaLocal(introSession);
		await IDBManager.saveSessionMessages(introId, introMessages);

		// 4. åˆ‡æ¢åˆ°è¯¥ä¼šè¯
		// ç”±äº saveSessionMetaLocal å·²ç»æ›´æ–°äº† sessions æ•°ç»„ï¼Œç›´æ¥ switch å³å¯
		await switchSession(introId);
	}

    async function createNewSession() {
        if (isProcessing) return;
        
        const newId = generateSessionId();
        const sysMsg = {
            role: 'system',
            content: "You are a helpful coding assistant. Answer concisely.",
            id: generateId(),
        };
        
        const newSession = {
            id: newId,
            title: 'New Session',
            timestamp: Date.now(),
        };

        currentSessionId = newId;
        chatHistory = [sysMsg];
        
        await saveSessionMetaLocal(newSession);
        await saveCurrentSession();

        messageArea.innerHTML = '';
        appendMessageToDOM('system', sysMsg.content, sysMsg.id, 'KERNEL_PROMPT');
        
        renderSidebar();
        userInput.focus();
    }

    async function updateSessionTitleIfNeeded(userText) {
        const session = sessions.find(s => s.id === currentSessionId);
        if (session && session.title === 'New Session') {
            session.title = userText.substring(0, 18) + (userText.length > 18 ? '...' : '');
            await saveSessionMetaLocal(session);
        }
    }

    // --- Initialization ---
    window.addEventListener('DOMContentLoaded', async () => {
        await IDBManager.init();
        await loadSessionsIndex();
        
        // --- åŠ¨æ€åŠ è½½æ¨¡å‹ ---
        await loadModels();
        
        if (sessions.length > 0) {
            const lastSession = sessions.sort((a, b) => b.timestamp - a.timestamp)[0];
            await switchSession(lastSession.id);
        } else {
			await createIntroSession();
            await createNewSession();
        }
    });

    // --- è·å–å¹¶æ¸²æŸ“æ¨¡å‹åˆ—è¡¨ ---
    async function loadModels() {
        try {
            // 1. è·å–æ¨¡å‹åˆ—è¡¨
            let models = await puter.ai.listModels();
            
            // 2. æŒ‰æä¾›å•†æˆ–åç§°ç®€å•æ’åº (å¯é€‰)
            models.sort((a, b) => a.id.localeCompare(b.id));

			// è¿‡æ»¤æ— æ•ˆçš„æ¨¡å‹
            models = models.filter(model => model.name);

            modelSelect.innerHTML = '';
            
            // å…ˆæ·»åŠ ä¼˜å…ˆæ¨¡å‹
            priorityModels.forEach(pid => {
                const m = models.find(x => x.id.includes(pid));
                if(m) createOption(m);
            });
            
			const separator = document.createElement('option');
			separator.disabled = true;
            separator.innerText = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
            modelSelect.appendChild(separator);

            models.forEach(m => {
                createOption(m);
            });

            // æ¢å¤ä¸Šæ¬¡é€‰æ‹©çš„æ¨¡å‹ (å¦‚æœæœ‰)
            const savedModel = localStorage.getItem('puter_last_model');
            if (savedModel && Array.from(modelSelect.options).some(o => o.value === savedModel)) {
                modelSelect.value = savedModel;
            }

        } catch (err) {
            console.error('Failed to load models:', err);
        }
    }

    function createOption(model) {
        const opt = document.createElement('option');
        opt.value = model.id;
        // æ˜¾ç¤º æ¨¡å‹ID æˆ– æ›´å‹å¥½çš„ Name
        opt.innerText = model.name || model.id;
        modelSelect.appendChild(opt);
    }

    // ç›‘å¬æ¨¡å‹æ”¹å˜ï¼Œä¿å­˜ç”¨æˆ·åå¥½
    modelSelect.addEventListener('change', () => {
        localStorage.setItem('puter_last_model', modelSelect.value);
    });

    newChatBtn.addEventListener('click', () => createNewSession());

    // --- Chat Logic ---
    userInput.addEventListener('input', function() {
        this.style.height = (this.scrollHeight) + 'px';
        if(this.value === '') this.style.height = '0px';
    });

    userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSend();
        }
    });

    sendBtn.addEventListener('click', () => handleSend());

    async function handleSend() {
        const text = userInput.value.trim();
        if (!text || isProcessing) return;
        
        userInput.value = '';
        userInput.style.height = '0px';

        await updateSessionTitleIfNeeded(text);

        const userMsgId = generateId();
        const userMsg = { role: 'user', content: text, id: userMsgId };
        chatHistory.push(userMsg);
        appendMessageToDOM('user', text, userMsgId);

		scrollToBottom(true);

        await saveCurrentSession();
        await performAIRequest();
    }

	async function performAIRequest(targetId = null) {
        if (isProcessing) return;
        
        const currentModel = modelSelect.value;
        toggleState(true);

        let aiMsgId, contextHistory;
        let uiElements;
        let fullText = ''; // ç”¨äºç´¯ç§¯å®Œæ•´çš„å›ç­”

        if (targetId) {
            aiMsgId = targetId;
            const targetIndex = chatHistory.findIndex(m => m.id === targetId);
            if (targetIndex === -1) { toggleState(false); return; }
            contextHistory = chatHistory.slice(0, targetIndex);
            
            const msgDiv = document.getElementById(targetId);
            const contentDiv = msgDiv.querySelector('.content');
            const metaDiv = msgDiv.querySelector('.meta-stats');
            
            contentDiv.textContent = "";
            contentDiv.classList.add('cursor'); // æ¿€æ´»å…‰æ ‡
            uiElements = { contentDiv, metaDiv };
        } else {
            aiMsgId = generateId();
            contextHistory = [...chatHistory];
            uiElements = appendMessageToDOM('assistant', '', aiMsgId, currentModel);
            uiElements.contentDiv.classList.add('cursor'); // æ–°æ¶ˆæ¯ä¹Ÿæ¿€æ´»å…‰æ ‡
        }

		uiElements.metaDiv.style.color = 'var(--text-color)';
        
        const startTime = Date.now();
        const timerInterval = setInterval(() => {
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            uiElements.metaDiv.innerText = `GENERATING: ${elapsed}s`;
        }, 100);

        try {
            const apiHistory = contextHistory.map(({role, content}) => ({role, content}));
            
            const response = await puter.ai.chat(apiHistory, {
                model: currentModel,
                stream: true
            });

            // 2. å¾ªç¯å¤„ç†æµæ•°æ®
            for await (const part of response) {
                // Puter.js v2 çš„æµå¼è¿”å›å¯¹è±¡é€šå¸¸åŒ…å« text å±æ€§
                const delta = part?.text || "";
                fullText += delta;
                
                const rawHTML = marked.parse(fullText);
                uiElements.contentDiv.innerHTML = DOMPurify.sanitize(rawHTML);

                scrollToBottom();
            }

            // 3. ä¼ è¾“ç»“æŸåçš„ç»Ÿè®¡
            clearInterval(timerInterval);
            const duration = ((Date.now() - startTime) / 1000).toFixed(2);
            const estimatedTokens = Math.max(1, Math.round(fullText.length / 2.5)); // ä¼°ç®— Token
            const tps = (estimatedTokens / duration).toFixed(1);

            uiElements.metaDiv.innerText = `Time: ${duration}s | ${tps} Token/s`;

            // 4. æ›´æ–°å†…å­˜ä¸­çš„å†å²è®°å½•
            if (targetId) {
				const targetIndex = chatHistory.findIndex(m => m.id === targetId);
				if (targetIndex !== -1) {
					chatHistory[targetIndex].content = fullText;
					// [æ–°å¢] æ›´æ–°å†å²è®°å½•ä¸­çš„æ¨¡å‹åç§°
					chatHistory[targetIndex].model = currentModel;
					
					const msgDiv = document.getElementById(targetId);
					const roleLabel = msgDiv.querySelector('.role-label span:first-child');
					roleLabel.innerText = currentModel.toUpperCase();
				}
			} else {
				// [ä¿®æ”¹] æ¨é€æ–°æ¶ˆæ¯æ—¶åŒ…å« model å­—æ®µ
				chatHistory.push({
					role: 'assistant',
					content: fullText,
					id: aiMsgId,
					model: currentModel,
				});
			}

            // 5. æœ€åå†ä¸€æ¬¡æ€§ä¿å­˜åˆ° IndexedDB (é¿å…é¢‘ç¹ IO)
            await saveCurrentSession();

        } catch (error) {
            clearInterval(timerInterval);
            console.error(error);
            uiElements.contentDiv.textContent += `\n\n[SYSTEM ERROR]: ${error.message}`;
            uiElements.metaDiv.innerText = `FAIL`;
            uiElements.metaDiv.style.color = '#ff3333';
        } finally {
            // ç§»é™¤å…‰æ ‡æ ·å¼ï¼Œæ¢å¤æŒ‰é’®çŠ¶æ€
            uiElements.contentDiv.classList.remove('cursor');
            toggleState(false);
            if (!targetId) scrollToBottom();
        }
    }

    function appendMessageToDOM(role, text, id, modelLabel = null, animate = true) {
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${role}`;
        if(animate) msgDiv.style.animation = 'fadeIn 0.3s ease';
        
        msgDiv.id = id;

        let displayLabel = role.toUpperCase();
        if (role === 'assistant' && modelLabel) displayLabel = modelLabel.toUpperCase();

        let buttonsHtml = `<button class="action-btn btn-del" onclick="confirmDeleteMsg('${id}')">[DEL]</button>`;
        let regenBtn = '';

        if (role === 'assistant') {
            regenBtn = `<button class="action-btn btn-regen" onclick="regenerateMessage('${id}')">[REGEN]</button>`;
        } else if (role === 'user') {
            // ä¸ºç”¨æˆ·æ·»åŠ é‡æ–°ç”Ÿæˆå›å¤çš„æŒ‰é’®
            regenBtn = `<button class="action-btn btn-regen" onclick="regenerateResponseTo('${id}')">[REGEN]</button>`;
        }

        // å°† regen æŒ‰é’®å’Œ del æŒ‰é’®æ”¾å…¥åŒä¸€ä¸ªå®¹å™¨
        buttonsHtml = `
            <div class="left-actions">
                ${regenBtn}
                ${buttonsHtml}
            </div>
        `;

        const cursorClass = (role === 'assistant' && text === '') ? 'cursor' : '';

        msgDiv.innerHTML = `
            <span class="role-label">
                <span>${displayLabel}</span>
            </span>
			<!-- <div class="content markdown-body ${cursorClass}" contenteditable="plaintext-only" spellcheck="false"></div> -->
            <div class="content markdown-body ${cursorClass}"></div>
            <div class="msg-footer">
                ${buttonsHtml}
                <div class="meta-stats"></div>
            </div>
        `;

        const contentArea = msgDiv.querySelector('.content');
        contentArea.textContent = text;

        messageArea.appendChild(msgDiv);
        if(animate) scrollToBottom();

        contentArea.addEventListener('input', () => {
            const newText = contentArea.innerText;
            updateHistoryContent(id, newText);
        });

        return {
            contentDiv: contentArea,
            metaDiv: msgDiv.querySelector('.meta-stats')
        };
    }

    async function updateHistoryContent(id, newText) {
        const item = chatHistory.find(m => m.id === id);
        if (item) {
            item.content = newText;
            await saveCurrentSession();
        }
    }

    window.regenerateMessage = function(id) {
        if (isProcessing) return;
        performAIRequest(id);
    }

	window.regenerateResponseTo = async function(id) {
        if (isProcessing) return;

        const userIndex = chatHistory.findIndex(m => m.id === id);
        if (userIndex === -1) return;

        const nextMsg = chatHistory[userIndex + 1];

        // æƒ…å†µ 1: ä¸‹ä¸€æ¡æ¶ˆæ¯å­˜åœ¨ä¸”æ˜¯ AI å›å¤ -> ç›´æ¥é‡æ–°ç”Ÿæˆè¯¥æ¡
        if (nextMsg && nextMsg.role === 'assistant') {
            await performAIRequest(nextMsg.id);
        }
        // æƒ…å†µ 2: ä¸‹ä¸€æ¡æ¶ˆæ¯ä¸å­˜åœ¨ï¼Œæˆ–è€…ä¸‹ä¸€æ¡æ˜¯ç”¨æˆ·æ¶ˆæ¯ (ä¸­é—´æ’å…¥) -> æ–°å»º AI æ¶ˆæ¯
        else {
            const currentModel = modelSelect.value;
            const newAiId = generateId();
            
            // 1. åœ¨å†å²è®°å½•æ•°ç»„ä¸­ï¼Œæ’å…¥åˆ°è¯¥ç”¨æˆ·æ¶ˆæ¯ä¹‹å
            const newMsgObj = {
                role: 'assistant',
                content: '',
                id: newAiId,
                model: currentModel
            };
            chatHistory.splice(userIndex + 1, 0, newMsgObj);

            // 2. åˆ›å»º DOM å…ƒç´ 
            // å…ˆé€šè¿‡ appendMessageToDOM åˆ›å»ºï¼ˆé»˜è®¤ä¼šåŠ åˆ°æœ€åï¼‰
            appendMessageToDOM('assistant', '', newAiId, currentModel, false);
            
            // 3. å°† DOM å…ƒç´ ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½® (å³ userId å¯¹åº”çš„å…ƒç´ ä¹‹å)
            const userDiv = document.getElementById(id);
            const newAiDiv = document.getElementById(newAiId);
            if (userDiv && newAiDiv) {
                if (userDiv.nextSibling) {
                    messageArea.insertBefore(newAiDiv, userDiv.nextSibling);
                } else {
                    messageArea.appendChild(newAiDiv);
                }
            }

            // 4. ä¿å­˜çŠ¶æ€å¹¶å¼€å§‹ç”Ÿæˆ
            await saveCurrentSession();
            await performAIRequest(newAiId);
        }
    }

    window.confirmDeleteMsg = async function(id) {
        const btn = document.querySelector(`#${id} .btn-del`);
        if (!btn) return;

        if (btn.innerText === '[DEL]') {
            btn.innerText = '[CONFIRM DELETE ?]';
            btn.classList.add('confirm-state');
            btn.timer = setTimeout(() => {
                if (btn) {
                    btn.innerText = '[DEL]';
                    btn.classList.remove('confirm-state');
                    btn.timer = null;
                }
            }, 2700);
        } else {
            if (btn.timer) clearTimeout(btn.timer);
            const el = document.getElementById(id);
            if (el) {
                el.style.opacity = '0';
                setTimeout(() => el.remove(), 200);
            }
            chatHistory = chatHistory.filter(item => item.id !== id);
            await saveCurrentSession();
        }
    }

    function toggleState(loading) {
        isProcessing = loading;
        sendBtn.disabled = loading;
        modelSelect.disabled = loading;
        document.querySelectorAll('.btn-regen').forEach(b => b.disabled = loading);

        if (loading) {
            statusDot.classList.add('active');
            sendBtn.innerText = "BUSY";
        } else {
            statusDot.classList.remove('active');
            sendBtn.innerText = "SEND";
        }
    }

	// ç›‘å¬æ»šåŠ¨äº‹ä»¶ï¼šç¢°åˆ°åº•éƒ¨è®¾ä¸º trueï¼Œç¦»å¼€åº•éƒ¨è®¾ä¸º false
	messageArea.addEventListener('scroll', () => {
        const threshold = 20;
        // åˆ¤æ–­å½“å‰æ»šåŠ¨ä½ç½®æ˜¯å¦åœ¨åº•éƒ¨
        isAutoScroll = messageArea.scrollTop + messageArea.clientHeight >= messageArea.scrollHeight - threshold;
    });

    function scrollToBottom(force = false) {
		if(force) isAutoScroll = true;
		if(!isAutoScroll) return;
        messageArea.scrollTop = messageArea.scrollHeight;
    }
</script>

</body>
</html>
